/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.24 from the
 * contents of FastMmap.xs. Do not edit this file, edit FastMmap.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "FastMmap.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"
#include "mmap_cache.h"

#define FC_UTF8VAL (1<<31)
#define FC_UTF8KEY (1<<30)
#define FC_UNDEF (1<<29)

#define FC_ENTRY \
    mmap_cache * cache; \
    if (!SvROK(obj)) { \
      croak("Object not reference"); \
      XSRETURN_UNDEF; \
    } \
    obj = SvRV(obj); \
    if (!SvIOKp(obj)) { \
      croak("Object not initiliased correctly"); \
      XSRETURN_UNDEF; \
    } \
    cache = INT2PTR(mmap_cache *, SvIV(obj) ); \
    if (!cache) { \
      croak("Object not created correctly"); \
      XSRETURN_UNDEF; \
    }


#line 40 "FastMmap.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 182 "FastMmap.c"

XS_EUPXS(XS_Cache__FastMmap_fc_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_new)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 36 "FastMmap.xs"
    mmap_cache * cache;
    SV * obj_pnt, * obj;
#line 195 "FastMmap.c"
#line 39 "FastMmap.xs"
    cache = mmc_new();

    /* Create integer which is pointer to cache object */
    obj_pnt = newSViv(PTR2IV(cache));

    /* Create reference to integer value. This will be the object */
    obj = newRV_noinc((SV *)obj_pnt);

    RETVAL = obj;
#line 206 "FastMmap.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cache__FastMmap_fc_set_param); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_set_param)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, param, val");
    {
	SV *	obj = ST(0)
;
	char *	param = (char *)SvPV_nolen(ST(1))
;
	char *	val = (char *)SvPV_nolen(ST(2))
;
	int	RETVAL;
	dXSTARG;
#line 57 "FastMmap.xs"
    FC_ENTRY

#line 232 "FastMmap.c"
#line 60 "FastMmap.xs"
    RETVAL = mmc_set_param(cache, param, val);
#line 235 "FastMmap.c"
#line 62 "FastMmap.xs"
    if (RETVAL != 0) {
      croak("%s", mmc_error(cache));
    }
#line 240 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cache__FastMmap_fc_init); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_init)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 70 "FastMmap.xs"
    FC_ENTRY

#line 260 "FastMmap.c"
#line 73 "FastMmap.xs"
    RETVAL = mmc_init(cache);
#line 263 "FastMmap.c"
#line 75 "FastMmap.xs"
    if (RETVAL != 0) {
      croak("%s", mmc_error(cache));
    }
#line 268 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cache__FastMmap_fc_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
#line 84 "FastMmap.xs"
    FC_ENTRY

#line 286 "FastMmap.c"
#line 87 "FastMmap.xs"
    mmc_close(cache);
    sv_setiv(obj, 0);
#line 290 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cache__FastMmap_fc_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_hash)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, key");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
	SV *	key = ST(1)
;
#line 96 "FastMmap.xs"
    int key_len;
    void * key_ptr;
    MU32 hash_page, hash_slot;
    STRLEN pl_key_len;

    FC_ENTRY

#line 317 "FastMmap.c"
#line 105 "FastMmap.xs"
    /* Get key length, data pointer */
    key_ptr = (void *)SvPV(key, pl_key_len);
    key_len = (int)pl_key_len;

    /* Hash key to get page and slot */
    mmc_hash(cache, key_ptr, key_len, &hash_page, &hash_slot);

    XPUSHs(sv_2mortal(newSViv((IV)hash_page)));
    XPUSHs(sv_2mortal(newSViv((IV)hash_slot)));
#line 328 "FastMmap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cache__FastMmap_fc_lock); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_lock)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, page");
    {
	SV *	obj = ST(0)
;
	UV	page = (UV)SvUV(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 121 "FastMmap.xs"
    FC_ENTRY

#line 351 "FastMmap.c"
#line 124 "FastMmap.xs"
    RETVAL = mmc_lock(cache, (MU32)page);
#line 354 "FastMmap.c"
#line 126 "FastMmap.xs"
    if (RETVAL != 0) {
      croak("%s", mmc_error(cache));
    }
#line 359 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cache__FastMmap_fc_unlock); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_unlock)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 135 "FastMmap.xs"
    FC_ENTRY

#line 379 "FastMmap.c"
#line 138 "FastMmap.xs"
    RETVAL = mmc_unlock(cache);
#line 382 "FastMmap.c"
#line 140 "FastMmap.xs"
    if (RETVAL != 0) {
      croak("%s", mmc_error(cache));
    }
#line 387 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cache__FastMmap_fc_is_locked); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_is_locked)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 148 "FastMmap.xs"
    FC_ENTRY

#line 407 "FastMmap.c"
#line 151 "FastMmap.xs"
    /* Write value to cache */
    RETVAL = mmc_is_locked(cache);

#line 412 "FastMmap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cache__FastMmap_fc_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_read)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, hash_slot, key");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
	U32	hash_slot = (unsigned long)SvUV(ST(1))
;
	SV *	key = ST(2)
;
#line 164 "FastMmap.xs"
    int key_len, val_len, found;
    void * key_ptr, * val_ptr;
    MU32 flags = 0;
    STRLEN pl_key_len;
    SV * val;

    FC_ENTRY

#line 443 "FastMmap.c"
#line 174 "FastMmap.xs"
    /* Get key length, data pointer */
    key_ptr = (void *)SvPV(key, pl_key_len);
    key_len = (int)pl_key_len;

    /* Get value data pointer */
    found = mmc_read(cache, (MU32)hash_slot, key_ptr, key_len, &val_ptr, &val_len, &flags);

    /* If not found, use undef */
    if (found == -1) {
      val = &PL_sv_undef;
    } else {

      /* Cached an undef value? */
      if (flags & FC_UNDEF) {
        val = &PL_sv_undef;

      } else {

        /* Create PERL SV */
        val = sv_2mortal(newSVpvn((const char *)val_ptr, val_len));

        /* Make UTF8 if stored from UTF8 */
        if (flags & FC_UTF8VAL) {
          SvUTF8_on(val);
        }

      }
      flags = flags & ~(FC_UTF8KEY | FC_UTF8VAL | FC_UNDEF);
    }

    XPUSHs(val);
    XPUSHs(sv_2mortal(newSViv((IV)flags)));
    XPUSHs(sv_2mortal(newSViv((IV)!found)));
#line 478 "FastMmap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cache__FastMmap_fc_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_write)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "obj, hash_slot, key, val, expire_seconds, in_flags");
    {
	SV *	obj = ST(0)
;
	U32	hash_slot = (unsigned long)SvUV(ST(1))
;
	SV *	key = ST(2)
;
	SV *	val = ST(3)
;
	U32	expire_seconds = (unsigned long)SvUV(ST(4))
;
	U32	in_flags = (unsigned long)SvUV(ST(5))
;
	int	RETVAL;
	dXSTARG;
#line 218 "FastMmap.xs"
    int key_len, val_len;
    void * key_ptr, * val_ptr;
    STRLEN pl_key_len, pl_val_len;

    FC_ENTRY

#line 513 "FastMmap.c"
#line 226 "FastMmap.xs"
    /* Get key length, data pointer */
    key_ptr = (void *)SvPV(key, pl_key_len);
    key_len = (int)pl_key_len;

    /* Check for storing undef, and store empty string with undef flag set */
    if (!SvOK(val)) {
      in_flags |= FC_UNDEF;

      val_ptr = "";
      val_len = 0;

    } else {

      /* Get key length, data pointer */
      val_ptr = (void *)SvPV(val, pl_val_len);
      val_len = (int)pl_val_len;

      /* Set UTF8-ness flag of stored value */
      if (SvUTF8(val)) {
        in_flags |= FC_UTF8VAL;
      }
      if (SvUTF8(key)) {
        in_flags |= FC_UTF8KEY;
      }
    }

    /* Write value to cache */
    RETVAL = mmc_write(cache, (MU32)hash_slot, key_ptr, key_len, val_ptr, val_len, (MU32)expire_seconds, (MU32)in_flags);

#line 544 "FastMmap.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cache__FastMmap_fc_delete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_delete)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, hash_slot, key");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
	U32	hash_slot = (unsigned long)SvUV(ST(1))
;
	SV *	key = ST(2)
;
	int	RETVAL;
	dXSTARG;
#line 264 "FastMmap.xs"
    MU32 out_flags;
    int key_len, did_delete;
    void * key_ptr;
    STRLEN pl_key_len;

    FC_ENTRY

#line 576 "FastMmap.c"
#line 273 "FastMmap.xs"
    /* Get key length, data pointer */
    key_ptr = (void *)SvPV(key, pl_key_len);
    key_len = (int)pl_key_len;

    /* Write value to cache */
    did_delete = mmc_delete(cache, (MU32)hash_slot, key_ptr, key_len, &out_flags);

    XPUSHs(sv_2mortal(newSViv((IV)did_delete)));
    XPUSHs(sv_2mortal(newSViv((IV)out_flags)));
#line 587 "FastMmap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cache__FastMmap_fc_get_page_details); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_get_page_details)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
#line 288 "FastMmap.xs"
    MU32 nreads = 0, nreadhits = 0;

    FC_ENTRY

#line 610 "FastMmap.c"
#line 293 "FastMmap.xs"
    mmc_get_page_details(cache, &nreads, &nreadhits);

    XPUSHs(sv_2mortal(newSViv((IV)nreads)));
    XPUSHs(sv_2mortal(newSViv((IV)nreadhits)));
#line 616 "FastMmap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cache__FastMmap_fc_reset_page_details); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_reset_page_details)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
#line 303 "FastMmap.xs"
    MU32 nreads = 0, nreadhits = 0;

    FC_ENTRY

#line 637 "FastMmap.c"
#line 308 "FastMmap.xs"
    mmc_reset_page_details(cache);
#line 640 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cache__FastMmap_fc_expunge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_expunge)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "obj, mode, wb, len");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
	int	mode = (int)SvIV(ST(1))
;
	int	wb = (int)SvIV(ST(2))
;
	int	len = (int)SvIV(ST(3))
;
#line 319 "FastMmap.xs"
    MU32 new_num_slots = 0, ** to_expunge = 0;
    int num_expunge, item;

    void * key_ptr, * val_ptr;
    int key_len, val_len;
    MU32 last_access, expire_time, flags;

    FC_ENTRY

#line 673 "FastMmap.c"
#line 330 "FastMmap.xs"
    num_expunge = mmc_calc_expunge(cache, mode, len, &new_num_slots, &to_expunge);
    if (to_expunge) {

      /* Want list of expunged keys/values? */
      if (wb) {

        for (item = 0; item < num_expunge; item++) {
          mmc_get_details(cache, to_expunge[item],
            &key_ptr, &key_len, &val_ptr, &val_len,
            &last_access, &expire_time, &flags);

          {
          HV * ih = (HV *)sv_2mortal((SV *)newHV());

          SV * key = newSVpvn((const char *)key_ptr, key_len);
          SV * val;

          if (flags & FC_UTF8KEY) {
            SvUTF8_on(key);
            flags ^= FC_UTF8KEY;
          }

          if (flags & FC_UNDEF) {
            val = newSV(0);
            flags ^= FC_UNDEF;
          } else {
            val = newSVpvn((const char *)val_ptr, val_len);
            if (flags & FC_UTF8VAL) {
              SvUTF8_on(val);
              flags ^= FC_UTF8VAL;
            }
          }

          /* Store in hash ref */
          hv_store(ih, "key", 3, key, 0); 
          hv_store(ih, "value", 5, val, 0);
          hv_store(ih, "last_access", 11, newSViv((IV)last_access), 0);
          hv_store(ih, "expire_time", 11, newSViv((IV)expire_time), 0);
          hv_store(ih, "flags", 5, newSViv((IV)flags), 0); 

          /* Create reference to hash */
          XPUSHs(sv_2mortal(newRV((SV *)ih)));
          }
        }
      }

      mmc_do_expunge(cache, num_expunge, new_num_slots, to_expunge);
    }
#line 723 "FastMmap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cache__FastMmap_fc_get_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_get_keys)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, mode");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
	int	mode = (int)SvIV(ST(1))
;
#line 387 "FastMmap.xs"
    mmap_cache_it * it;
    MU32 * entry_ptr;
    void * key_ptr, * val_ptr;
    int key_len, val_len;
    MU32 last_access, expire_time, flags;

    FC_ENTRY

#line 752 "FastMmap.c"
#line 397 "FastMmap.xs"
    it = mmc_iterate_new(cache);

    /* Iterate over all items */
    while (entry_ptr = mmc_iterate_next(it)) {
      SV *  key;
      mmc_get_details(cache, entry_ptr,
        &key_ptr, &key_len, &val_ptr, &val_len,
        &last_access, &expire_time, &flags);

      /* Create key SV, and set UTF8'ness if needed */
      key = newSVpvn((const char *)key_ptr, key_len);
      if (flags & FC_UTF8KEY) {
        SvUTF8_on(key);
        flags ^= FC_UTF8KEY;
      }

      /* Mode 0 is just list of keys */
      if (mode == 0) {
        XPUSHs(sv_2mortal(key));

      /* Mode 1/2 is list of hash-refs */
      } else if (mode == 1 || mode == 2) {
        HV * ih = (HV *)sv_2mortal((SV *)newHV());

        /* These things by default */
        hv_store(ih, "key", 3, key, 0); 
        hv_store(ih, "last_access", 11, newSViv((IV)last_access), 0);
        hv_store(ih, "expire_time", 11, newSViv((IV)expire_time), 0);
        hv_store(ih, "flags", 5, newSViv((IV)flags), 0); 

        /* Add value to hash-ref if mode 2 */
        if (mode == 2) {
          SV * val;
          if (flags & FC_UNDEF) {
            val = newSV(0);
            flags ^= FC_UNDEF;
          } else {
            val = newSVpvn((const char *)val_ptr, val_len);
            if (flags & FC_UTF8VAL) {
              SvUTF8_on(val);
              flags ^= FC_UTF8VAL;
            }
          }
          hv_store(ih, "value", 5, val, 0);
        }

        /* Create reference to hash */
        XPUSHs(sv_2mortal(newRV((SV *)ih)));
      }
    }

    mmc_iterate_close(it);
#line 806 "FastMmap.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Cache__FastMmap_fc_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "obj, key");
    {
	SV *	obj = ST(0)
;
	SV *	key = ST(1)
;
	SV *	RETVAL;
#line 459 "FastMmap.xs"
    int key_len, val_len, found;
    void * key_ptr, * val_ptr;
    MU32 hash_page, hash_slot, flags;
    STRLEN pl_key_len;
    SV * val;

    FC_ENTRY

#line 834 "FastMmap.c"
#line 469 "FastMmap.xs"
    /* Get key length, data pointer */
    key_ptr = (void *)SvPV(key, pl_key_len);
    key_len = (int)pl_key_len;

    /* Hash key to get page and slot */
    mmc_hash(cache, key_ptr, key_len, &hash_page, &hash_slot);

    /* Get and lock the page */
    mmc_lock(cache, hash_page);

    /* Get value data pointer */
    found = mmc_read(cache, hash_slot, key_ptr, key_len, &val_ptr, &val_len, &flags);

    /* If not found, use undef */
    if (found == -1) {
      val = &PL_sv_undef;
    } else {

      /* Create PERL SV */
      val = newSVpvn((const char *)val_ptr, val_len);
    }

    mmc_unlock(cache);
    RETVAL = val;
#line 860 "FastMmap.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Cache__FastMmap_fc_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "obj, key, val");
    {
	SV *	obj = ST(0)
;
	SV *	key = ST(1)
;
	SV *	val = ST(2)
;
#line 503 "FastMmap.xs"
    int key_len, val_len, found;
    void * key_ptr, * val_ptr;
    MU32 hash_page, hash_slot, flags = 0;
    STRLEN pl_key_len, pl_val_len;

    FC_ENTRY

#line 889 "FastMmap.c"
#line 512 "FastMmap.xs"
    /* Get key length, data pointer */
    key_ptr = (void *)SvPV(key, pl_key_len);
    key_len = (int)pl_key_len;

    /* Get key length, data pointer */
    val_ptr = (void *)SvPV(val, pl_val_len);
    val_len = (int)pl_val_len;

    /* Hash key to get page and slot */
    mmc_hash(cache, key_ptr, key_len, &hash_page, &hash_slot);

    /* Get and lock the page */
    mmc_lock(cache, hash_page);

    /* Get value data pointer */
    mmc_write(cache, hash_slot, key_ptr, key_len, val_ptr, val_len, -1, flags);

    mmc_unlock(cache);
#line 909 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Cache__FastMmap_fc_dump_page); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Cache__FastMmap_fc_dump_page)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
#line 536 "FastMmap.xs"
    FC_ENTRY

#line 927 "FastMmap.c"
#line 539 "FastMmap.xs"
    _mmc_dump_page(cache);
#line 930 "FastMmap.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Cache__FastMmap); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Cache__FastMmap)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Cache::FastMmap::fc_new", XS_Cache__FastMmap_fc_new, file, "");
        (void)newXSproto_portable("Cache::FastMmap::fc_set_param", XS_Cache__FastMmap_fc_set_param, file, "$$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_init", XS_Cache__FastMmap_fc_init, file, "$");
        (void)newXSproto_portable("Cache::FastMmap::fc_close", XS_Cache__FastMmap_fc_close, file, "$");
        (void)newXSproto_portable("Cache::FastMmap::fc_hash", XS_Cache__FastMmap_fc_hash, file, "$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_lock", XS_Cache__FastMmap_fc_lock, file, "$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_unlock", XS_Cache__FastMmap_fc_unlock, file, "$");
        (void)newXSproto_portable("Cache::FastMmap::fc_is_locked", XS_Cache__FastMmap_fc_is_locked, file, "$");
        (void)newXSproto_portable("Cache::FastMmap::fc_read", XS_Cache__FastMmap_fc_read, file, "$$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_write", XS_Cache__FastMmap_fc_write, file, "$$$$$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_delete", XS_Cache__FastMmap_fc_delete, file, "$$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_get_page_details", XS_Cache__FastMmap_fc_get_page_details, file, "$");
        (void)newXSproto_portable("Cache::FastMmap::fc_reset_page_details", XS_Cache__FastMmap_fc_reset_page_details, file, "$");
        (void)newXSproto_portable("Cache::FastMmap::fc_expunge", XS_Cache__FastMmap_fc_expunge, file, "$$$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_get_keys", XS_Cache__FastMmap_fc_get_keys, file, "$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_get", XS_Cache__FastMmap_fc_get, file, "$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_set", XS_Cache__FastMmap_fc_set, file, "$$$");
        (void)newXSproto_portable("Cache::FastMmap::fc_dump_page", XS_Cache__FastMmap_fc_dump_page, file, "$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

